<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="/assets/css/styles.css">
    <title>csci 1300 final</title>
  </head>
  <body>
    <nav>
    
      <a href="/" >
        hhe07/ <br>
      </a>
    
      <a href="/about.html" >
        about/ <br>
      </a>
    
      <a href="/coursework.html" >
        coursework/ <br>
      </a>
    
      <a href="/computing.html" >
        computing/ <br>
      </a>
    
      <a href="/photo.html" >
        photography/ <br>
      </a>
    
      <a href="/music.html" >
        music/ <br>
      </a>
    
      <a href="/blog.html" >
        blog/ <br>
      </a>
    
  </nav>
    <div class = "main">
      <h1>csci 1300 final</h1>

    hhe07


<div class="post">
    <p><img src="/assets/imgs/csgame.png" alt="Screenshot of some game output" /></p>

<p>My final project for my introductory C++ class is basically representative of my programming abilities in C++. I think what’s notable about it is not necessarily the specific code or extent of the C++ programming language that I used (since we weren’t allowed to use pointers, and I hadn’t learned much advanced C++), but the structure of the program and the way that I thought about the problem. For context, the final project was to build a basic RPG with some specific structural requirements, either off of a template provided by the course, or using a self-made design. I initially chose to design my own project, but I correctly recognised that my concept was not feasible by the deadline. The requirements can be found <a href="https://github.com/CSCI1300-StartingComputing/CSCI1300-Fall2022/blob/main/project/project3/project3.md">here</a>, but broadly involved:</p>
<ul>
  <li>the use of some objects and student-created classes</li>
  <li>the use of arrays</li>
  <li>the use of control flow and iteration structures</li>
  <li>file input and output</li>
  <li>implementation of the required features</li>
</ul>

<p>I was most pleased with my ability to structure the entire program in a logical and reasonably clean way. First, rather than having classes handle their own terminal output and reading of terminal inputs, I consolidated all those situations to two classes (which nested with each other). As a result, the flow of terminal data followed a segmented and clear path for debugging: the main loop read terminal data, which was then sent to a option receiver in the relevant class to be sent to the relevant method for processing, which then applied changes to the internal game data and the output objects (a <code class="language-plaintext highlighter-rouge">map</code> of <code class="language-plaintext highlighter-rouge">string</code> to <code class="language-plaintext highlighter-rouge">string</code> to print the menu presented to the player at a given point, and an additional <code class="language-plaintext highlighter-rouge">string</code> for displaying extra information).</p>

<p>Additionally, since I noticed that many of the classes that I had planned required access to many of the core elements of the game’s data, I created an <code class="language-plaintext highlighter-rouge">Assets</code> class and some associated <code class="language-plaintext highlighter-rouge">structs</code> to load and store shared parts of the game’s data from text files (such as weapon names and statistics, cookware names and statistics, a list of monsters which hadn’t yet been fought, etc.), reducing code reuse for reading from files and sharing manipulated data between classes.</p>

<p>Finally, I think the <code class="language-plaintext highlighter-rouge">Driver</code> class is notable as a successful attempt to work around some of the restrictions of the project. The better way to make a UI menu would likely be to use a map of strings to function pointers or something. Despite the length of the <code class="language-plaintext highlighter-rouge">Driver</code> class, the broad division of <em>handling</em> input and <em>modifying</em> output was quite good. Otherwise, I was happy about the division of features into various functions, since it confirmed some of my previous decisions in the cleanliness of the code and the level of organisation.</p>

<p>There are definitely shortcomings, however — I think that a further level of abstraction is necessary in the driver, perhaps to divide the input and output functionality from some of the game logic. Otherwise, I think the frequent use of <code class="language-plaintext highlighter-rouge">map</code> data structures in <code class="language-plaintext highlighter-rouge">Assets</code> isn’t the most efficient solution, because some of the code used to interface with them is somewhat clunky. Finally, I think that the output objects could be optimized. The output <code class="language-plaintext highlighter-rouge">map</code> needs to be cleared before every iteration, which is a significant bottleneck; and a large portion of the length of the <code class="language-plaintext highlighter-rouge">Driver</code> class is taken up by handling addition of menu elements to the output <code class="language-plaintext highlighter-rouge">map</code>. I can’t think of a very definite solution right now, but perhaps a binary search tree / graph would be ideal for the menu interface, and some sort of hash table / ID system would be ideal for the various <code class="language-plaintext highlighter-rouge">map</code>s in <code class="language-plaintext highlighter-rouge">Assets</code>.</p>

<p>Regardless, you can find the code and instructions for running it <a href="https://github.com/hhe07/csci1300_final">here</a>. I think this project is a decent representation of how far I’ve come in <em>thinking about</em> programming — not necessarily the features I know how to use or the specific methods that I’m aware of, but thinking about the program <em>as a whole</em> and planning it out.</p>

</div>
    </div>
  </body>
</html>