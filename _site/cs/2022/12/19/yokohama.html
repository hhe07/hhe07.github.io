<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="/assets/css/styles.css">
    <title>yokohama</title>
  </head>
  <body>
    <nav>
    
      <a href="/" >
        hhe07/ <br>
      </a>
    
      <a href="/about.html" >
        about/ <br>
      </a>
    
      <a href="/computing.html" >
        computing/ <br>
      </a>
    
      <a href="/photo.html" >
        photography/ <br>
      </a>
    
      <a href="/music.html" >
        music/ <br>
      </a>
    
      <a href="/blog.html" >
        blog/ <br>
      </a>
    
  </nav>
    <div class = "main">
      <h1>yokohama</h1>

    <p><i> in progress //  writeup 19 Dec 2022 // hhe07</i></p>


<div class="post">
    <p>As discussed previously within the <a href="/cs/2022/12/19/csci-1300-final.html">CSCI 1300 Final Project</a> post, I previously had an idea for a game of my own design, which I’ll be working on over my winter break. It’s based on the manga <a href="https://en.wikipedia.org/wiki/Yokohama_Kaidashi_Kik%C5%8D">Yokohama Kaidashi Kikou</a> (YKK), and focuses on exploration and taking the world in rather than combat.</p>

<p>I’ll post more details when I’ve made some more progress, but I’m planning on making the game in Go, with the Charmbracelet <a href="https://github.com/charmbracelet/bubbletea"><code class="language-plaintext highlighter-rouge">bubbletea</code></a> and <a href="https://github.com/charmbracelet/bubbles"><code class="language-plaintext highlighter-rouge">bubbles</code></a> packages for UI control. Despite my problems with them for more complicated UIs, as described in the Collage section of <a href="/cs/2022/12/19/misc.html">misc</a>, I think it’ll work fine for the relatively simple interface with only one input area that the yokohama game requires.</p>

<p>Here’s the basic planning document put together for class, but which will definitely be helpful in my own development:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- project story
	- start: starting off living at the cafe. protagonist has some experiences, but user will be introduced to things from scratch
	- "end": memories collection completed. game will still be playable afterwards, due to random events, managing shop, interacting with people, etc.
- game flow:
    - user will have to explore the world and solve basic puzzles / interact with people in order to gain items and progress to later areas.
    - there will be larger quest-like chains of events during the story, such as saving up for a long trip, which will require more than 1 resource and more than 1 action
    - three main resource categories:
        - money: used to pay for some items, and may be a barrier for some of the quest-like chains
        - memories: gained when completing an event / event chain. also used to gate exploration. stored in photo album.
        - items: does what it says on the tin. some are reuseable, some are not. 
    - photo album: used as a means of determining player progress. entries are updated as events are completed
- external files
    - definitely:
        - progression data: player stats, current "date", certain flags to indicate progress / key events, etc.
            - events will be written to a file as a set of booleans / ints to indicate completion, which will be read once the game starts.
            - ideally events will be structured in a way that they don't interlink with each other too much, so the "break" caused by restarting the game is easier to handle, and so more advanced playthroughs can load fewer events, saving on memory
        - event data, item data, npc data, location data: data will be read from these files and turned into objects.
    - potentially:
        - art: ASCII art for locations / NPC faces / item icons
- class design
    - Player class: stores player information (done)
        - (date / time, memories, items, photo album, current Events, Map bounds)
    - Event class: stores event information (done)
        - Prerequisites: item(s), memories, map locations discovered
        - Stores data about completion conditions and rewards (photo album entries, memories, or items)
        - Current hint: some way of steering a player along
        - Status markers: some ways of judging completion progress: possibly a counter or something
    - DialogueTree class: stores dialogue trees and provides methods of applying their "consequences"
        - Each node contains "visited" boolean, content, and choices
        - Each leaf specifies which action type to do: modify Player class attributes, give an Event, modify an Event
        - Includes functions to give next dialogue option (which also may gate progress based on Event data in the following leaf)
            - "supplemental" dialoguetree files start with something to know where to connect to
    - NPC class (done)
        - Stores DialogueTree(s) of the NPC, as well as (potentially) their art and name
        - (optional feature): list of locations that they will go to at certain times, or their random events
    - Memory class (done)
        - Basically a wrapper to include description, "time" when obtained, and name
        - May also include a bit of art if that feature's included
    - Location class (done)
        - Contains an array of the indices of connected locations
        - Has a function to check the photo album, items, and memories to see if new locations can be unlocked
        - Includes function to return whether following locations are accessible
        - Also will include list of NPCs, which will be the "actions" at that location
        - Facilitates loading of dialogue trees of NPCs based off of player state
    - Map class (done)
        - A 2D array of Locations, with soft "bounds" information to gate player access
        - Will call the function under Location to determine new location access and update that access (honestly not sure where to handle this task)
        - Will also return a visual representation of the map, taking into account bounds and what the player has unlocked
    - Client class
        - Handles inputs and outputs to the other constituent classes.
        - Handles loading and un-loading of NPCs, Events, 
        - Handles writeback and cursor position management

misc
- how to handle in-event progress?
- thoughts on scope?
	- cutting functionality: first to go would be Events: things that the player needs to do will be one-and-done, no complicated multi-stage events
- ncurses?
- are we allowed to add / remove methods in between code skeleton and final submission?

random number of money from customers?
keep shop should be an NPC to simplify if necessary.

think about progress class design in a second
memory files are mem_file_{id}

what is meant by number of menu options: total, or including nested?

add NPCs to gamemap

map moved to global state
</code></pre></div></div>

<p>Stay tuned for more!</p>

</div>
    </div>
  </body>
</html>